# самый короткий из всех мной написанных вариант
#import itertools as i,functools as f
#golf_=lambda l:round(min(f.reduce(lambda a,x:a+((x[0][0]-x[1][0])**2+(x[0][1]-x[1][1])**2)**0.5,
#                                 zip(((0,0),)+l,l),0) for l in i.permutations(l)),2)
#длина 185

# еше один очень короткий вариант
#import itertools as i,functools as f,math as m
#golf=lambda l:round(min(f.reduce(lambda a,x:a+m.hypot(x[0][0]-x[1][0],x[0][1]-x[1][1]),
#                                 zip(((0,0),)+l,l),0) for l in i.permutations(l)),2)
#длина 187

# нашел в интернете
# охуительное рекурсивное решение
# сам до него не додумался
# что важно, тут есть работа с комплексными числами
# раньше мне не приходилось такое использовать

# во-первых, удивительно, что тут можно использовать значения по умолчанию
# раньше мне это не приходило в голову
golf=lambda s,a=0,b=0:\
    min( # находим минимум штуки ниже
        abs(a-x[0]+1j*(b-x[1]))+ # ищем расстояние от точки a до текущей точки
        # добавляем к нему расстояние от точки b до текущей точки
        # хитрый, очень хитрый ход с комплексными числами
        golf(s-{x},*x) # рекурсивный вызов с множеством всех точек, кроме x
        for x in s # перебираем по всем точкам последовательности
    )\
        if s else 0 # выдаем 0, если входная последовательность пустая

golf({(2, 2), (2, 8), (8, 8), (8, 2), (5, 5)})